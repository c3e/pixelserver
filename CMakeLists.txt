cmake_minimum_required(VERSION 2.8)

project(pixeldecke)

set(${PROJECT_NAME}_VERSION_MAJOR 2)
set(${PROJECT_NAME}_VERSION_MINOR 0)
set(${PROJECT_NAME}_VERSION_SUFFIX "")

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++17")

if (BUILD_STATIC)
	set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -static -static-libgcc")
endif()

# Define a __FILENAME__ macro to get the filename of each file, instead of
# the full path as in __FILE__
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -D__FILENAME__='\"$(subst ${CMAKE_SOURCE_DIR}/,,$(abspath $<))\"'")

#
## Look for external libraries
#
set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${CMAKE_CURRENT_SOURCE_DIR}/cmake/Modules/")

#
## Get the software version
#
set(ARCHIVE_NAME ${CMAKE_PROJECT_NAME}-${${PROJECT_NAME}_VERSION_MAJOR}.${${PROJECT_NAME}_VERSION_MINOR})
if(${PROJECT_NAME}_VERSION_SUFFIX MATCHES ".+")
  set(ARCHIVE_NAME ${ARCHIVE_NAME}-${${PROJECT_NAME}_VERSION_SUFFIX})
endif()

if(${PROJECT_NAME}_VERSION_SUFFIX MATCHES "^~dev$")
  # If we are on a dev version, append the hash of the current git HEAD to
  # the version
  include(FindGit)
  if(GIT_FOUND AND EXISTS "${CMAKE_SOURCE_DIR}/.git")
    execute_process(COMMAND git --git-dir=${CMAKE_SOURCE_DIR}/.git rev-parse --short HEAD
      OUTPUT_VARIABLE GIT_REVISION
      OUTPUT_STRIP_TRAILING_WHITESPACE)
    if(GIT_REVISION)
      set(${PROJECT_NAME}_VERSION_SUFFIX "${${PROJECT_NAME}_VERSION_SUFFIX} (${GIT_REVISION})")
      set(ARCHIVE_NAME ${ARCHIVE_NAME}-${GIT_REVISION})
    endif()
  endif()
endif()

set(SOFTWARE_VERSION
  ${${PROJECT_NAME}_VERSION_MAJOR}.${${PROJECT_NAME}_VERSION_MINOR}${${PROJECT_NAME}_VERSION_SUFFIX})

# To be able to include the config.h file generated by cmake
include_directories("${CMAKE_CURRENT_BINARY_DIR}/src/")
include_directories("${CMAKE_CURRENT_SOURCE_DIR}/src/")

#
## json
#
file(GLOB source_json libs/json/*.[hc]pp)
add_library(json STATIC ${source_json})
target_link_libraries(json)


#
## pixelflut
#
file(GLOB source_pixelflut
  src/pixelflut/*.[hc]pp)
add_library(pixelflut STATIC ${source_pixelflut})
target_link_libraries(pixelflut serial utils)


# Searches package MOSQUITTO 
# definition is in ./cmake/FindMOSQUITTO.cmake
# find_package(MOSQUITTO REQUIRED)

#
## mqtt
#

file(GLOB source_mqtt
  src/mqtt/*.[hc]pp)
add_library(mqtt STATIC ${source_mqtt})
target_link_libraries(mqtt utils)

if (BUILD_STATIC)
  file(GLOB source_libcrypto libs/openssl/libcrypto.a)
  file(GLOB source_libssl libs/openssl/libssl.a)
	file(GLOB source_libmos libs/mosquitto/build/lib/libmosquitto.a )
	target_link_libraries(mqtt ${source_libssl} ${source_libcrypto} ${source_libmos})
endif()

#
## animations
#

file(GLOB source_animations
  src/animations/*.[hc]pp)
add_library(animations STATIC ${source_animations})
target_link_libraries(animations utils rapidjson)

#
## http
#

file(GLOB source_http
  src/http/*.[hc]pp)
add_library(http STATIC ${source_http})
target_link_libraries(http serial utils json)

if (BUILD_STATIC)
	file(GLOB source_libev libs/libevent/build/lib/libevent.a )
	target_link_libraries(http ${source_libev})
endif()


set(THREADS_PREFER_PTHREAD_FLAG ON)
find_package(Threads REQUIRED)

#
## utils
#
file(GLOB source_utils
  src/utils/*.[hc]p*)
add_library(utils STATIC ${source_utils})
target_link_libraries(utils Threads::Threads)


#
## serial
#
file(GLOB source_serial
  src/serial/*.[hc]pp)
add_library(serial STATIC ${source_serial})
target_link_libraries(serial utils)


#
## Main executable
#
add_executable(${PROJECT_NAME} src/main.cpp)
target_link_libraries(${PROJECT_NAME}
  http
  serial
  mqtt
  utils
  pixelflut
	#event
	#mosquitto
	#ssl
	#crypto
	)
if (BUILD_STATIC)
  target_link_libraries(${PROJECT_NAME} ${source_libssl} ${source_libcrypto})
else () 
	target_link_libraries(${PROJECT_NAME} event mosquitto)
endif()	




#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>
#include <errno.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
//#include <SDL.h>
#include "utils.cpp"
#include "serial_control.cpp"

decke *d;

#define BUFSIZE 2048

#define XSTR(a) #a
#define STR(a) XSTR(a)

uint32_t* pixels;
volatile int running = 1;
volatile int client_thread_count = 0;
volatile int server_sock;

void * handle_client(void *);
void * handle_clients(void *);

uint32_t PIXEL_WIDTH;
uint32_t PIXEL_HEIGHT;
uint16_t PORT;
pthread_t thread_id;

void set_pixel(uint16_t x, uint16_t y, uint32_t c, uint8_t a)
{
   if(x < PIXEL_WIDTH && y < PIXEL_HEIGHT){
      if(a == 255){ // fast & usual path
         //pixels[y * PIXEL_WIDTH + x] = 0xff000000 | c; // ARGB
         return;
      }
      // alpha path
      uint8_t src_r = (c >> 16);
      uint8_t src_g = (c >> 8) & 0xff;
      uint8_t src_b = (c & 0xff);
      uint32_t dst_c = pixels[y * PIXEL_WIDTH + x];
      uint8_t dst_r = (dst_c >> 16);
      uint8_t dst_g = (dst_c >> 8) & 0xff;
      uint8_t dst_b = (dst_c & 0xff);
      uint8_t na = 255 - a;
      uint16_t r = src_r * a + dst_r * na;
      uint16_t g = src_g * a + dst_g * na;
      uint16_t b = src_b * a + dst_b * na;
      printf("Color Value: %lu \n", c << 8| a);
      d->setPixel(x,y,c << 8 | a); // ARGB
   }
}


void * handle_client(void *s){
   client_thread_count++;
   int sock = *(int*)s;
   char buf[BUFSIZE];
   int read_size, read_pos = 0;
   uint32_t x,y,c;
   while(running && (read_size = recv(sock , buf + read_pos, sizeof(buf) - read_pos , 0)) > 0){
      read_pos += read_size;
      int found = 1;
      while (found){
         found = 0;
         for (int i = 0; i < read_pos; i++){
            if (buf[i] == '\n'){
               buf[i] = 0;
#if 1 // mit alpha, aber ggf. instabil
               if(!strncmp(buf, "PX ", 3)){ // ...frag nicht :D... // compare as uint32_t
                  char *pos1 = buf + 3;
                  x = strtoul(buf + 3, &pos1, 10); //OK
                  if(buf != pos1){
                     pos1++;
                     char *pos2 = pos1;
                     y = strtoul(pos1, &pos2, 10); //OK
                     if(pos1 != pos2){
                        pos2++;
                        pos1 = pos2;
                        c = strtoul(pos2, &pos1, 16);
                        if(pos2 != pos1){
                           uint8_t a = 255;
                           if((pos1 - pos2) > 6){ // contains alpha
                              a = c & 0xff;
                              c >>= 8;
                           }
                           log("Went through\n");
                           set_pixel(x,y,c,a);
                        }
                     }
                  }
               }
#else // ohne alpha
               if(sscanf(buf,"PX %u %u %x",&x,&y,&c) == 3){
                  set_pixel(x,y,c, 0xff);
               }
#endif
               else if(!strncmp(buf, "SIZE", 4)){
                  static const char out[] = "SIZE " STR(PIXEL_WIDTH) " " STR(PIXEL_HEIGHT) "\n";
                  send(sock, out, sizeof(out), MSG_DONTWAIT | MSG_NOSIGNAL);
               }
               else{
                  printf("QUATSCH[%i]: ", i);
                  for (int j = 0; j < i; j++)
                     printf("%c", buf[j]);
                  printf("\n");
               }
               int offset = i + 1;
               int count = read_pos - offset;
               if (count > 0)
                  memmove(buf, buf + offset, count); // TODO: ring buffer?
               read_pos -= offset;
               found = 1;
               break;
            }
         }
         if (sizeof(buf) - read_pos == 0){ // received only garbage for a whole buffer. start over!
            buf[sizeof(buf) - 1] = 0;
            printf("GARBAGE BUFFER: %s\n", buf);
            read_pos = 0;
         }
      }
   }
   close(sock);
   log("Client disconnected\n");
   fflush(stdout);
   client_thread_count--;
   return 0;
}

void * handle_clients(void * foobar){
   pthread_t thread_id;
   int client_sock;
   socklen_t addr_len;
   struct sockaddr_in addr;
   addr_len = sizeof(addr);
   struct timeval tv;
   
   log("Starting Pixelflut Server...\n");
   
   server_sock = socket(PF_INET, SOCK_STREAM, 0);

   tv.tv_sec = 2;
   tv.tv_usec = 0;

   addr.sin_addr.s_addr = INADDR_ANY;
   addr.sin_port = htons(PORT);
   addr.sin_family = AF_INET;
   
   if (server_sock == -1){
      log("socket() failed");
      return 0;
   }

   int val = 1;
   
   if (setsockopt(server_sock, SOL_SOCKET, SO_REUSEADDR, &val, sizeof(int)) < 0)
      printf("setsockopt(SO_REUSEADDR) failed\n");
   if (setsockopt(server_sock, SOL_SOCKET, SO_REUSEPORT, &val, sizeof(int)) < 0)
      printf("setsockopt(SO_REUSEPORT) failed\n");

   int retries;
   for (retries = 0; bind(server_sock, (struct sockaddr*)&addr, sizeof(addr)) == -1 && retries < 10; retries++){
      log("bind() failed ...retry in 5s");
      usleep(5000000);
   }
   if (retries == 10)
      return 0;

   if (listen(server_sock, 3) == -1){
      perror("listen() failed");
      return 0;
   }
   log("Pixelflut is Listening...\n");
   
   setsockopt(server_sock, SOL_SOCKET, SO_SNDTIMEO, (char *)&tv,sizeof(struct timeval));
   setsockopt(server_sock, SOL_SOCKET, SO_RCVTIMEO, (char *)&tv,sizeof(struct timeval));

   while(IsRun){
      client_sock = accept(server_sock, (struct sockaddr*)&addr, &addr_len);
      if(client_sock > 0){
         logn("Client ", inet_ntoa(addr.sin_addr)," connected\n");
         if( pthread_create( &thread_id , NULL ,  handle_client , (void*) &client_sock) < 0)
         {
            close(client_sock);
            log("Pixelflut couldn't create thread for client\n");
         }
      }
   }
   close(server_sock);
   return 0;
}


int init_pixelflut(uint32_t height, uint32_t width, uint32_t port, decke &dd){
   PORT = port;
   PIXEL_HEIGHT = height;
   PIXEL_WIDTH = width;

   d = &dd;

   if(pthread_create(&thread_id , NULL, handle_clients , NULL) < 0){
      log("Pixelflut Initialization thread couldn't be allocated");
      //free(pixels);
      //SDL_Quit();
      return 1;
   }
   
   return 0;
}

// Not needed anymore, everything based on 'IsRun'
int stop_pixelflut(){

   
   printf("Shutting Down...\n");
   //SDL_DestroyWindow(window);
   while (client_thread_count)
      usleep(100000);
   close(server_sock);
   pthread_join(thread_id, NULL);
   return 0;
}
